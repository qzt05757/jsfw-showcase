JavaScript のフレームワークが大量にあって違いが分かりにくいので、
同じアプリケーションを各フレームワーク上に実装して、違いを明確にする

あまりにもシンプルなアプリケーションだとつまらないので、以下の特徴のアプリケーションとする
- サーバの REST API を呼び出す
- bootstarp で HTML を作る

ただし、途中で飽きる可能性高し


動かす場合、
gradle インストール後、gradle jettyRun でサーバが起動するので、
ブラウザで http://localhost:8080/jsfw-showcase/ を表示する

* jquery.js

jquery 上でも綺麗にコーディングできるが、普通に書くと
ビューの中にモデルの値が混在する形となってしまう。

* backbone.js

jquery とは異なり、ビューとモデルは分離。ビューは HTML、モデルは JavaScript で記述
ビューからモデル、モデルからビューの値の同期は自分でコーディングする必要あり

結構コードが冗長になるような・・・

* knockout.js

ビューとモデルは分離。ビューは HTML、モデルは JavaScript で記述
ビュー側に対応するモデルを記述すれば、ビューとモデルの値の同期は FW が行う。
モデル定義に Knockout が依存する (ko.observable とか)が美しくないと思う

* ember.js

イメージでは knockout.js に近い

* angular.js(1.x)

フルスタックのフレームワーク
他のフレームワークが Model と View の分離が主眼であるのに対して、REST の呼び出し等
クライアントアプリ全般をカバーしたフレームワーク

* react.js

ビューとモデルのどちらも JavaScript で記述する。(ビューは JSX という HTML 風のシンタクスを利用)
コンポーネント単位にビューとモデルがまとまる形のため、部品化しやすい(かもしれない)

ただし、HTML ベースではないため、デザイナが HTML を作成して、そのあとでプログラマが
ロジックを埋め込む、という開発スタイルとは整合しづらいかもしれない

* reactive.js

ビューとモデルは分離。ビューは HTML、モデルは JavaScript で記述。

HTML をコンポーネント単位で記述するため、react.js と同様にデザイナ作の HTML をベースに
ロジックを追加する開発とは相性が悪いかもしれない

* vue.js

しらない

* Aurelia.js

しらない。

* 参考
- http://paiza.hatenablog.com/entry/2015/03/11/Backbone_JS%E3%81%8B%E3%82%89Angular2%E3%81%BE%E3%81%A7%E3%80%81%E5%85%A89%E5%A4%A7JavaScript%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%92%E6%9B%B8%E3%81%8D%E6%AF%94%E3%81%B9